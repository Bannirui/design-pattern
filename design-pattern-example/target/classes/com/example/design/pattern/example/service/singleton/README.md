## 单例模式 Singleton

### 模式定义
保证一个类只有一个实例，并且提供一个全局访问点

### 场景
重量级的对象，不需要多个实例，如线程池、数据库连接池

### 实现方式
* 饿汉式(静态常量)
  * 类加载的初始化阶段就完成了实例的初始化，本质上是借助于JVM类加载机制保证实例的唯一性
  * 优点是写法比较简单，在类装载的时候完成实例化，避免了线程同步问题
  * 缺点是在装载的时候就完成实例化，没有达到lazy loading效果，如果从始至终没有使用过这个实例，则会造成内存浪费
  * 这种方式基于classloader机制避免了多线程的同步问题，不过instance在类装载的时候就实例化，在单例模式中大多数都是调用getInstance方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式导致类装载，这时候初始化Instance就没有达到lazy loading的效果
  * 这种单例模式可用，可能造成内存浪费
  
* 饿汉式(静态代码块)
  * 实例化过程放在静态代码块中，也是在类装载的时候就执行静态代码块中的代码，初始化类的实例
  * 优缺点和饿汉模式(静态常量)一样

* 懒汉式(线程不安全)
  * 起到了lazy loading的效果，但是只能在单线程下使用
  * 如果在多线程下，一个线程进入了instance==null的判断语句块，还未来得及执行，另一个线程也通过了这个判断语句，这时便产生了多个实例
  * 实际开发中，不使用这种方式

* 懒汉式(线程安全 同步方法)
  * 解决了线程不安全问题
  * 效率太低，每个线程在想获得类的实例的时候，执行getInstance()方法都要进行同步，其实这个方法只要执行一次实例化就够了，后面想获得该害实例直接return就行了
  * 实际开发中，不使用这种方式

* 懒汉式(双重检查)：
  * Double-Check概念在多线程开发中经常使用，保证线程安全
  * 实例化代码只执行了一次，后面再次访问时判断instance==null就直接return实例化对象，避免了反复进行方法同步
  * 线程安全，延迟加载，效率较高
  * 在实际开发中，推荐使用这种单例设计模式
  
* 静态内部类：本质上是利用类的加载机制保证线程安全，只有在实际使用时才会触发类的初始化，也是懒加载的一种形式
  * 这种方式采用了类装载的机制为保证初始化实例时只有一个线程
  * 静态内部类方式在Singleton类被装载时不会立即实例化，而是在需要实例化时调用getInstance方法才会装载静态内部类，从而完成实例化
  * 类的静态属性只会在第一次加载类的时候初始化，JVM帮助保证了线程的安全性，在类进行初始化时，别的线程无法进入
  * 避免了线程不安全，利用静态内部类特点实现了延迟加载，效率高
  * 推荐使用
  
* 枚举
  * 借助JDK枚举实现单例，避免线程同步问题，防止反序列化重新创建对象
  * 推荐使用